<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction / Tutorial · AuditoryStimuli.jl</title><meta name="title" content="Introduction / Tutorial · AuditoryStimuli.jl"/><meta property="og:title" content="Introduction / Tutorial · AuditoryStimuli.jl"/><meta property="twitter:title" content="Introduction / Tutorial · AuditoryStimuli.jl"/><meta name="description" content="Documentation for AuditoryStimuli.jl."/><meta property="og:description" content="Documentation for AuditoryStimuli.jl."/><meta property="twitter:description" content="Documentation for AuditoryStimuli.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">AuditoryStimuli.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Introduction / Tutorial</a><ul class="internal"><li><a class="tocitem" href="#Set-up-the-signal-pipeline-components"><span>Set up the signal pipeline components</span></a></li><li><a class="tocitem" href="#Run-the-real-time-audio-pipeline"><span>Run the real-time audio pipeline</span></a></li><li><a class="tocitem" href="#Verify-processing-was-correctly-applied"><span>Verify processing was correctly applied</span></a></li><li><a class="tocitem" href="#Apply-a-filter-modifier"><span>Apply a filter modifier</span></a></li><li><a class="tocitem" href="#Modifying-modifier-parameters"><span>Modifying modifier parameters</span></a></li><li><a class="tocitem" href="#Verify-output"><span>Verify output</span></a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../example-ssr/">Amplitude Modulated Noise</a></li><li><a class="tocitem" href="../example-hs/">Harmonic Stacks</a></li><li><a class="tocitem" href="../example-bpnoise/">Bandpass Noise</a></li><li><a class="tocitem" href="../example-itd/">Interaural Time Delay</a></li><li><a class="tocitem" href="../example-itmfr/">ITD Modulation</a></li><li><a class="tocitem" href="../example-signoise/">Signal and Noise</a></li></ul></li><li><a class="tocitem" href="../advanced/">Advanced Usage</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction / Tutorial</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction / Tutorial</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/rob-luke/AuditoryStimuli.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/rob-luke/AuditoryStimuli.jl/blob/main/docs/src/realtime-introduction.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Real-Time-Audio-Processing"><a class="docs-heading-anchor" href="#Real-Time-Audio-Processing">Real-Time Audio Processing</a><a id="Real-Time-Audio-Processing-1"></a><a class="docs-heading-anchor-permalink" href="#Real-Time-Audio-Processing" title="Permalink"></a></h1><p>In this tutorial the basics of real-time audio processing are introduced, and how you can generate real time audio with this package.</p><p>It is common to process audio in small chunks of samples called frames. This is more efficient than processing signals on a sample by sample basis, yet allows dynamic adaptation of the audio signal. In this example we use a frame size of 1/100th of a second, or 480 samples when using a sample rate of 48 kHz. However, the frame size can be adjusted to suit your research needs.</p><p>Real-time processing consists of a source, zero or more modifiers, and a sink. Sources generate the raw signal. Modifiers alter the signal. Sinks are a destination for the signals, typically a sound card, but in this example we use a buffer.</p><p>First the required packages are loaded and the sample rate and number of audio channels is specified. This package makes extensive use of units to minimise the chance of coding mistakes, below the sample rate is specified in the unit of kHz.</p><pre><code class="language-julia hljs">using AuditoryStimuli, Unitful, Plots, Pipe, DSP

sample_rate = 48u&quot;kHz&quot;
audio_channels = 2
source_rms = 0.2</code></pre><h2 id="Set-up-the-signal-pipeline-components"><a class="docs-heading-anchor" href="#Set-up-the-signal-pipeline-components">Set up the signal pipeline components</a><a id="Set-up-the-signal-pipeline-components-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-the-signal-pipeline-components" title="Permalink"></a></h2><p>First we need a source. In this example a simple white noise source is used. The type of data (floats) is specified, as is the the sample rate, number of channels, and the RMS of each channel.</p><pre><code class="language-julia hljs">source = NoiseSource(Float64, sample_rate, audio_channels, source_rms)</code></pre><p>A sink is also required. This would typically be a sound card, but that is not possible with a web page tutorial. Instead, for this website example a dummy sink is used, which simply saves the sample to a buffer. Dummy sink are also useful for validating our generated stimuli, as we can measure and plot the output.</p><pre><code class="language-julia hljs">sink = DummySampleSink(Float64, sample_rate, audio_channels)

# But on a real system you would use something like
# devices = PortAudio.devices()
# println(devices)
# sink = PortAudioStream(devices[3], sample_rate, audio_channels)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">DummySampleSink{Float64}(48000.0, Matrix{Float64}(undef, 0, 2))</code></pre><p>In this example a single signal modifier is used. This signal modifier simply adjusts the amplitude of the signal with a linear scaling. We specify the desired linear amplification to be 1.0, so no modification to the amplitude. However, we do not want the signal to jump from silent to full intensity, so we specify the current value of the amplitude as 0 (silent) and set the maximum increase per frame to be 0.05. This will ramp the signal from silent to full intensity.</p><pre><code class="language-julia hljs">amp = Amplification(current=0.0, target=1.0, change_limit=0.05)</code></pre><h2 id="Run-the-real-time-audio-pipeline"><a class="docs-heading-anchor" href="#Run-the-real-time-audio-pipeline">Run the real-time audio pipeline</a><a id="Run-the-real-time-audio-pipeline-1"></a><a class="docs-heading-anchor-permalink" href="#Run-the-real-time-audio-pipeline" title="Permalink"></a></h2><p>To run the real-time processing we generate a pipeline and run it. We use the <code>pipe</code> notation to conveniently describe the audio pipeline. In this simple example we read a frame with duration 1/100th of a second from the source. The frame of white noise is piped through the amplitude modifier, and then piped in to the sink. Modifiers always take the modification object as the first argument, followed by an underscore to represent the piped data. Similarly, when writing the data to a sink, the sink is always the first argument, followed by an underscore to represent the piped data. The pipeline is run 100 times, resulting in 1 second of generated audio.</p><pre><code class="language-julia hljs">for frame = 1:100
    @pipe read(source, 0.01u&quot;s&quot;) |&gt; modify(amp, _) |&gt; write(sink, _)
end</code></pre><h2 id="Verify-processing-was-correctly-applied"><a class="docs-heading-anchor" href="#Verify-processing-was-correctly-applied">Verify processing was correctly applied</a><a id="Verify-processing-was-correctly-applied-1"></a><a class="docs-heading-anchor-permalink" href="#Verify-processing-was-correctly-applied" title="Permalink"></a></h2><p>We can plot the data from sink (as it was a DummySink, which is simply a buffer) to confirm the signal generated matches our expectations. As expected, we see below that two channels of audio are generated, that the signal is 1 second long, and that there is a ramp applied to the onset.</p><pre><code class="language-julia hljs">plot(sink)</code></pre><img src="862496fe.png" alt="Example block output"/><h2 id="Apply-a-filter-modifier"><a class="docs-heading-anchor" href="#Apply-a-filter-modifier">Apply a filter modifier</a><a id="Apply-a-filter-modifier-1"></a><a class="docs-heading-anchor-permalink" href="#Apply-a-filter-modifier" title="Permalink"></a></h2><p>A more advanced application is to use a filter as a modifier. The filter maintains its state between calls, so can be used for real-time audio processing. Below a bandpass filter is designed, for more details on filter design using the DSP package see <a href="https://docs.juliadsp.org/stable/filters/">this documentation</a>.</p><pre><code class="language-julia hljs">responsetype = Bandpass(500, 4000; fs=48000)
designmethod = Butterworth(4)
zpg = digitalfilter(responsetype, designmethod)</code></pre><p>Once the filter is specified as a zero pole gain representation two filters are instantiated using this specification. A filter must be generated for each channel of audio. These DSP.Filters are then passed in to the AuditoryStimuli filter object for further use.</p><pre><code class="language-julia hljs">f_left = DSP.Filters.DF2TFilter(zpg)
f_right = DSP.Filters.DF2TFilter(zpg)
bandpass = AuditoryStimuli.Filter([f_left, f_right])</code></pre><p>Once the filters are designed and placed in an AuditoryStimuli.Filter object they can be used just like any other modifier. Below the filter is included in the pipeline and applied to 1 second of audio in 1/100th second frames. This example demonstrates how an arbitrary number of modifiers can be chained to create complex audio stimuli.</p><pre><code class="language-julia hljs">for frame = 1:100
    @pipe read(source, 0.01u&quot;s&quot;) |&gt; modify(amp, _) |&gt; modify(bandpass, _) |&gt; write(sink, _)
end</code></pre><h2 id="Modifying-modifier-parameters"><a class="docs-heading-anchor" href="#Modifying-modifier-parameters">Modifying modifier parameters</a><a id="Modifying-modifier-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Modifying-modifier-parameters" title="Permalink"></a></h2><p>Further, the parameters of modifiers can be varied at any time. This can be handy to adapt your stimuli to user responses or feedback. Below the target amplification is updated to be set to zero. This effectively ramps off the signal.</p><pre><code class="language-julia hljs">setproperty!(amp, :target, 0.0)
for frame = 1:20
    @pipe read(source, 0.01u&quot;s&quot;) |&gt; modify(amp, _) |&gt; modify(bandpass, _) |&gt; write(sink, _)
end</code></pre><h2 id="Verify-output"><a class="docs-heading-anchor" href="#Verify-output">Verify output</a><a id="Verify-output-1"></a><a class="docs-heading-anchor-permalink" href="#Verify-output" title="Permalink"></a></h2><p>The entire signal (both the amplification, then the filtering sections) can be viewed using the convenience plotting function below. We observe that the signal is ramped on due to the amplification modifier. We can then see that at 1 second the spectral content of the signal was modified. And finally the signal is ramped off.</p><pre><code class="language-julia hljs">PlotSpectroTemporal(sink, figure_size=(700, 400), frequency_limits = [0, 8000])</code></pre><img src="8f17c64a.png" alt="Example block output"/></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../example-ssr/">Amplitude Modulated Noise »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Friday 2 February 2024 02:32">Friday 2 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
